<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cassette Runtime Loader</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: #f5f5f5;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .card {
      background-color: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .input-group {
      display: flex;
      margin-bottom: 10px;
    }
    .input-group input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px 0 0 4px;
    }
    .input-group button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 0 4px 4px 0;
      cursor: pointer;
    }
    .logs {
      background-color: #000000;
      color: #4CAF50;
      padding: 10px;
      border-radius: 4px;
      font-family: monospace;
      height: 300px;
      overflow-y: auto;
    }
    .log-entry {
      margin-bottom: 5px;
      line-height: 1.4;
      font-family: monospace;
    }
    .receive {
      color: #4CAF50;
    }
    .send {
      color: #2196F3;
    }
    .error {
      color: #f44336;
    }
    h2 {
      margin-top: 0;
    }
    .flex {
      display: flex;
      gap: 20px;
    }
    .flex > div {
      flex: 1;
    }
    .preset-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
    }
    .preset-buttons button {
      padding: 5px 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .tab-container {
      display: flex;
      border-bottom: 1px solid #ddd;
      margin-bottom: 15px;
    }
    .tab {
      padding: 10px 20px;
      cursor: pointer;
      border: 1px solid transparent;
      border-radius: 4px 4px 0 0;
    }
    .tab.active {
      border: 1px solid #ddd;
      border-bottom: none;
      background-color: white;
    }
    .tab-panel {
      display: none;
    }
    .tab-panel.active {
      display: block;
    }
    #drop-zone {
      border: 2px dashed #ccc;
      border-radius: 8px;
      padding: 25px;
      text-align: center;
      margin-bottom: 20px;
      background-color: #f9f9f9;
      transition: all 0.3s;
    }
    #drop-zone.drag-over {
      background-color: #e3f2fd;
      border-color: #2196F3;
    }
    .custom-tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
    }
    .custom-tab {
      position: relative;
      padding-right: 30px;
    }
    .remove-tab {
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      background: #ff5252;
      color: white;
      border: none;
      border-radius: 50%;
      width: 18px;
      height: 18px;
      font-size: 10px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .loaded-cassettes {
      margin-top: 10px;
    }
    .cassette-badge {
      background-color: #e0f7fa;
      color: #006064;
      padding: 5px 10px;
      border-radius: 15px;
      font-size: 12px;
      margin-right: 5px;
      margin-bottom: 5px;
      display: inline-block;
    }
    .response-card {
      margin-top: 10px;
      background-color: #f0f8ff;
      border-left: 4px solid #007bff;
      padding: 10px;
    }
    .json-content {
      white-space: pre-wrap;
      font-family: monospace;
      font-size: 12px;
    }
    .tab-info {
      font-size: 12px;
      color: #777;
      margin-top: 5px;
    }
    .test-panel {
      margin-top: 15px;
    }
    .metric {
      display: inline-block;
      margin-right: 15px;
      font-size: 14px;
    }
    .metric-value {
      font-weight: bold;
      color: #007bff;
    }
    .empty-state {
      text-align: center;
      padding: 40px;
      color: #888;
    }
    .empty-state i {
      font-size: 48px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Cassette Runtime Loader</h1>
    
    <div class="card">
      <h2>Load Cassette</h2>
      <div id="drop-zone">
        <p>Drag and drop a .wasm file here or click to select a file</p>
        <input type="file" id="file-input" accept=".wasm" style="display: none;">
        <button id="select-file" style="background-color: #2196F3; color: white; border: none; padding: 10px 20px; cursor: pointer; border-radius: 4px;">Select File</button>
      </div>
      
      <div class="loaded-cassettes">
        <h3>Loaded Cassettes</h3>
        <div id="cassette-list">
          <div class="empty-state">
            <p>No cassettes loaded yet</p>
          </div>
        </div>
      </div>
    </div>
    
    <div class="card">
      <div class="tab-container">
        <div class="tab active" data-tab="request">Send Request</div>
        <div class="tab" data-tab="response">Response</div>
        <div class="tab" data-tab="debug">Debug</div>
      </div>
      
      <div class="tab-panel active" id="request-panel">
        <div class="input-group">
          <input type="text" id="request-input" placeholder='Enter a request (e.g. ["REQ", "subscription1", {"kinds":[1], "limit": 5}])'>
          <button id="send-request">Send</button>
        </div>
        
        <div class="preset-buttons">
          <button data-preset='["REQ", "req1", {"kinds": [1], "limit": 5}]'>REQ 5 Notes</button>
          <button data-preset='["REQ", "req2", {"kinds": [0], "limit": 1}]'>Metadata</button>
          <button data-preset='["REQ", "req3", {"authors": ["3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d"]}]'>By Author</button>
          <button data-preset='["REQ", "req4", {"#e": ["3bf0c63fcb93463407af97a5e5ee64fa883d107ef9e558472c4eb9aaaefa459d"]}]'>By E Tag</button>
          <button data-preset='["REQ", "req5", {"since": 1600000000}]'>Since Timestamp</button>
          <button data-preset='["CLOSE", "req1"]'>Close REQ1</button>
        </div>
      </div>
      
      <div class="tab-panel" id="response-panel">
        <div id="response-container">
          <div class="empty-state">
            <p>No response yet</p>
          </div>
        </div>
      </div>
      
      <div class="tab-panel" id="debug-panel">
        <h3>Logs</h3>
        <button id="clear-logs" style="margin-bottom: 10px;">Clear Logs</button>
        <div id="logs" class="logs"></div>
      </div>
    </div>
  </div>

  <!-- Add fallback UMD bundles with multiple paths -->
  <script>
    // Try to load the UMD bundle from multiple potential locations
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${src}`));
        document.head.appendChild(script);
      });
    }
    
    // Try loading from various paths - add more relative paths and absolute paths
    loadScript('../cassette-loader/dist/browser/cassette-loader.umd.js')
      .catch(() => loadScript('../../cassette-loader/dist/browser/cassette-loader.umd.js'))
      .catch(() => loadScript('./node_modules/cassette-loader/dist/browser/cassette-loader.umd.js'))
      .catch(() => loadScript('/cassette-loader/dist/browser/cassette-loader.umd.js'))
      // Add these new paths
      .catch(() => loadScript('/node_modules/cassette-loader/dist/browser/cassette-loader.umd.js'))
      .catch(() => loadScript('../node_modules/@cassette-loader/dist/browser/cassette-loader.umd.js'))
      .catch(() => loadScript('./cassette-loader.umd.js')) // Try in the same directory
      .catch(error => {
        console.warn('Failed to load UMD bundle from any location', error);
        // Add this explicit log about where to get the file from
        console.warn('Please check that cassette-loader is installed and the file exists at one of the attempted paths');
      });
  </script>
  
  <script type="module">
    // Add error handling for import and try multiple paths
    let CassetteManager;
    
    try {
      // First check if UMD bundle already loaded the library
      if (window.CassetteLoader && window.CassetteLoader.CassetteManager) {
        CassetteManager = window.CassetteLoader.CassetteManager;
        addLogEntryDirect('Using CassetteManager from UMD bundle', 'receive');
      } else {
        // Try different import paths based on our findings
        const module = await import('../../cassette-loader/dist/browser/cassette-loader.js')
          .catch(error => {
            console.error('First import path failed:', error);
            return import('../cassette-loader/dist/browser/cassette-loader.js');
          })
          .catch(error => {
            console.error('Second import path failed:', error);
            return import('./node_modules/cassette-loader/dist/browser/cassette-loader.js');
          })
          .catch(error => {
            console.error('Third import path failed:', error);
            return import('../node_modules/cassette-loader/dist/browser/cassette-loader.js');
          })
          // Add these new paths
          .catch(error => {
            console.error('Fourth import path failed:', error);
            return import('/node_modules/cassette-loader/dist/browser/cassette-loader.js');
          })
          .catch(error => {
            console.error('Fifth import path failed:', error);
            return import('./cassette-loader.js'); // Try in the same directory
          })
          .catch(error => {
            console.error('All import paths failed:', error);
            
            // Check again if UMD bundle loaded while we were trying imports
            if (window.CassetteLoader && window.CassetteLoader.CassetteManager) {
              return { CassetteManager: window.CassetteLoader.CassetteManager };
            }
            
            addLogEntryDirect('Failed to import cassette-loader module. Check console for details.', 'error');
            throw error;
          });
        
        CassetteManager = module.CassetteManager;
        addLogEntryDirect('Successfully imported CassetteManager via ES module', 'receive');
      }
    } catch (error) {
      console.error('Error during import:', error);
      addLogEntryDirect('Fatal error importing CassetteManager: ' + error.message, 'error');
      
      // One final check for UMD bundle
      if (window.CassetteLoader && window.CassetteLoader.CassetteManager) {
        CassetteManager = window.CassetteLoader.CassetteManager;
        addLogEntryDirect('Recovered using CassetteManager from UMD bundle', 'receive');
      }
    }
    
    // Helper function to add logs (available before other code loads)
    function addLogEntryDirect(message, type = '') {
      const logs = document.getElementById('logs');
      if (!logs) {
        console.log('Logs element not found, logging to console:', message);
        console.log(message);
        return;
      }
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = message;
      logs.appendChild(entry);
      logs.scrollTop = logs.scrollHeight;
      
      // If it's an error, automatically show the debug tab
      if (type === 'error' && typeof showDebugTab === 'function') {
        showDebugTab();
      }
    }
    
    // Create a new cassette manager
    let manager;
    try {
      manager = new CassetteManager({ debug: true });
      addLogEntryDirect('CassetteManager initialized', 'receive');
      
      // Add loadCassetteFromArrayBuffer method if it doesn't exist
      if (!manager.loadCassetteFromArrayBuffer) {
        addLogEntryDirect('Adding loadCassetteFromArrayBuffer method to CassetteManager', 'receive');
        manager.loadCassetteFromArrayBuffer = async function(arrayBuffer, fileName, options = {}) {
          // This is a simple implementation that uses the existing loadCassetteFromFile method
          // Create a Blob from the ArrayBuffer
          const blob = new Blob([arrayBuffer], { type: 'application/wasm' });
          
          // Create a File object from the Blob
          const file = new File([blob], fileName || 'unknown.wasm', { 
            type: 'application/wasm',
            lastModified: new Date().getTime()
          });
          
          // Use the existing loadCassetteFromFile method
          return await this.loadCassetteFromFile(file, options);
        };
      }
    } catch (error) {
      console.error('Failed to initialize CassetteManager:', error);
      addLogEntryDirect('Failed to initialize CassetteManager. Check console for details.', 'error');
    }
    
    let activeCassetteId = null;
    
    // Helper function to add log entries
    function addLogEntry(message, type = '') {
      addLogEntryDirect(message, type);
    }
    
    // Initialize UI immediately, don't wait for DOMContentLoaded since the script is at the end of the body
    // Set up tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        // Hide all panels and deactivate tabs
        document.querySelectorAll('.tab-panel').forEach(panel => {
          panel.classList.remove('active');
        });
        document.querySelectorAll('.tab').forEach(t => {
          t.classList.remove('active');
        });
        
        // Show selected panel and activate tab
        const tabName = this.getAttribute('data-tab');
        document.getElementById(`${tabName}-panel`).classList.add('active');
        this.classList.add('active');
        
        // If switching to debug tab, scroll logs to bottom
        if (tabName === 'debug') {
          const logs = document.getElementById('logs');
          if (logs) {
            logs.scrollTop = logs.scrollHeight;
          }
        }
      });
    });
    
    // Add a helper function to switch to debug tab
    function showDebugTab() {
      const debugTab = document.querySelector('.tab[data-tab="debug"]');
      if (debugTab) {
        debugTab.click();
      }
    }
    
    // Set up drag and drop for cassette files
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const selectFileBtn = document.getElementById('select-file');
    
    // Add debug log to verify initialization
    addLogEntry('UI initialized, setting up file handlers', 'receive');
    
    // Add specific detection for common WebAssembly issues
    if (typeof WebAssembly === 'object') {
      addLogEntry('WebAssembly is supported in this browser', 'receive');
      
      // Check for TypedArray support
      if (typeof Uint8Array === 'function' && typeof TextEncoder === 'function') {
        addLogEntry('TypedArray and TextEncoder support detected', 'receive');
        
        // Register a global handler to detect the specific typed array error
        window.addEventListener('error', function(event) {
          if (event.error && event.error.message && event.error.message.includes('typed array length')) {
            console.error('Detected typed array length error:', event.error);
            addLogEntry(`Detected typed array error: ${event.error.message}`, 'error');
            // Show debug tab when this error occurs
            showDebugTab();
          }
        });
      } else {
        addLogEntry('WARNING: Missing TypedArray or TextEncoder support', 'error');
      }
    } else {
      addLogEntry('WARNING: WebAssembly is not supported in this browser', 'error');
    }
    
    // File input click handler - use direct method instead of event
    if (selectFileBtn && fileInput) {
      selectFileBtn.onclick = (e) => {
        e.preventDefault();
        addLogEntry('Select file button clicked', 'receive');
        fileInput.click();
      };
    } else {
      addLogEntry('File input elements not found!', 'error');
    }
    
    // File input change handler - make sure this works
    fileInput.addEventListener('change', (e) => {
      addLogEntry('File input changed', 'receive');
      if (e.target.files.length > 0) {
        handleCassetteFile(e.target.files[0]);
      }
    });
    
    // Drag and drop handlers - use direct assignments for better browser compatibility
    if (dropZone) {
      // Prevent default to allow drop
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
      });
      
      // Add visual feedback
      ['dragenter', 'dragover'].forEach(eventName => {
        dropZone.addEventListener(eventName, highlight, false);
      });
      
      ['dragleave', 'drop'].forEach(eventName => {
        dropZone.addEventListener(eventName, unhighlight, false);
      });
      
      // Handle drop
      dropZone.addEventListener('drop', handleDrop, false);
      
      addLogEntry('Drag and drop handlers installed', 'receive');
    } else {
      addLogEntry('Drop zone element not found!', 'error');
    }
    
    function preventDefaults(e) {
      e.preventDefault();
      e.stopPropagation();
    }
    
    function highlight() {
      dropZone.classList.add('drag-over');
      addLogEntry('File dragged over drop zone', 'receive');
    }
    
    function unhighlight() {
      dropZone.classList.remove('drag-over');
    }
    
    function handleDrop(e) {
      unhighlight();
      addLogEntry('File dropped', 'receive');
      
      if (e.dataTransfer.files.length > 0) {
        const files = e.dataTransfer.files;
        for (let i = 0; i < files.length; i++) {
          handleCassetteFile(files[i]);
        }
      }
    }
    
    // Set up preset buttons
    document.querySelectorAll('.preset-buttons button').forEach(button => {
      button.addEventListener('click', function() {
        const preset = this.getAttribute('data-preset');
        document.getElementById('request-input').value = preset;
      });
    });
    
    // Set up send request button
    document.getElementById('send-request').addEventListener('click', sendRequest);
    
    // Allow enter key to send request
    document.getElementById('request-input').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        sendRequest();
      }
    });
    
    // Clear logs
    document.getElementById('clear-logs').addEventListener('click', () => {
      document.getElementById('logs').innerHTML = '';
    });
    
    // Function to handle loading a cassette file
    async function handleCassetteFile(file) {
      addLogEntry(`Processing file: ${file.name} (${file.size} bytes, type: ${file.type})`, 'receive');
      
      if (!file.name.endsWith('.wasm')) {
        addLogEntry(`Invalid file type. Only .wasm files are supported.`, 'error');
        return;
      }
      
      if (!manager) {
        addLogEntry(`Cannot load cassette: CassetteManager not initialized`, 'error');
        return;
      }
      
      try {
        addLogEntry(`Loading cassette: ${file.name}...`, 'receive');
        
        // Read the file manually to verify we can access its contents
        const fileReader = new FileReader();
        
        fileReader.onload = async (event) => {
          const arrayBuffer = event.target.result;
          addLogEntry(`File read successfully, size: ${arrayBuffer.byteLength} bytes`, 'receive');
          
          try {
            // Create options with a safer loading approach
            const loadOptions = {
              safeMetadataLoading: true,  // Use our custom metadata loading approach
              useChunkedMetadata: true,   // Load metadata in chunks if available
              metadataFallback: {         // Fallback metadata if parsing fails
                name: file.name,
                description: "Metadata couldn't be parsed safely",
                version: "unknown",
                author: "unknown",
                created: new Date().toISOString()
              }
            };
            
            // Load the cassette using the CassetteManager with safe options
            let cassette;
            try {
              // First try with our enhanced options
              cassette = await manager.loadCassetteFromArrayBuffer(arrayBuffer, file.name, loadOptions);
              addLogEntry('Loaded cassette with safe metadata approach', 'receive');
            } catch (loadError) {
              addLogEntry(`Safe loading error: ${loadError.message}`, 'error');
              
              // If there's a typed array error, use our specialized approach
              if (loadError.message && loadError.message.includes('typed array length')) {
                addLogEntry('Detected typed array length error, attempting specialized loading...', 'receive');
                
                try {
                  // Create WebAssembly instance manually
                  const wasmModule = await WebAssembly.compile(arrayBuffer);
                  const instance = await WebAssembly.instantiate(wasmModule, {});
                  
                  // Check for specialized chunked metadata functions
                  const exports = instance.exports;
                  const hasChunkedMetadata = typeof exports.get_description_size === 'function' && 
                                           typeof exports.get_description_chunk === 'function';
                  
                  if (hasChunkedMetadata) {
                    addLogEntry('Found chunked metadata functions, using them to safely load metadata', 'receive');
                    
                    try {
                      // Get the total size of the description
                      const descSize = exports.get_description_size();
                      addLogEntry(`Metadata size: ${descSize} bytes`, 'receive');
                      
                      // Load metadata in chunks of 1000 bytes (safe size for TypedArrays)
                      const chunkSize = 1000;
                      let fullMetadata = '';
                      
                      for (let i = 0; i < descSize; i += chunkSize) {
                        const chunk = exports.get_description_chunk(i, chunkSize);
                        fullMetadata += chunk;
                      }
                      
                      // Create a custom cassette object with our safely loaded metadata
                      const customCassette = {
                        id: `safe_${Date.now()}`,
                        name: file.name,
                        description: fullMetadata,
                        size: arrayBuffer.byteLength,
                        instance: exports,
                        methods: {
                          req: exports.req,
                          close: exports.close,
                          describe: () => fullMetadata,
                          getSchema: exports.get_schema
                        }
                      };
                      
                      // Add the cassette manually
                      if (typeof manager.addCassette === 'function') {
                        manager.addCassette(customCassette);
                        cassette = customCassette;
                        addLogEntry('Successfully added cassette with chunked metadata approach', 'receive');
                      } else {
                        throw new Error('Cannot add cassette: addCassette not available');
                      }
                    } catch (chunkError) {
                      addLogEntry(`Error loading chunked metadata: ${chunkError.message}`, 'error');
                      throw chunkError;
                    }
                  } else {
                    // No chunked functions found, try with minimal metadata
                    addLogEntry('No chunked metadata functions found, using minimal approach', 'receive');
                    
                    // Create a minimal cassette with available exports
                    const manualCassette = {
                      id: `manual_${Date.now()}`,
                      name: file.name,
                      description: JSON.stringify({
                        metadata: {
                          name: file.name,
                          description: "WASM module loaded with minimal metadata",
                          version: "unknown",
                          created: new Date().toISOString()
                        }
                      }),
                      size: arrayBuffer.byteLength,
                      instance: exports,
                      methods: {
                        req: findExport(exports, ['req', 'request']),
                        close: findExport(exports, ['close', 'cancel']),
                        describe: () => JSON.stringify({
                          metadata: {
                            name: file.name,
                            description: "WASM module loaded with minimal metadata",
                            version: "unknown",
                            created: new Date().toISOString()
                          }
                        }),
                        getSchema: findExport(exports, ['get_schema', 'getSchema', 'schema'])
                      }
                    };
                    
                    // Add to manager manually
                    if (typeof manager.addCassette === 'function') {
                      manager.addCassette(manualCassette);
                      cassette = manualCassette;
                      addLogEntry('Added cassette with minimal metadata', 'receive');
                    } else {
                      throw new Error('Cannot add cassette: addCassette not available');
                    }
                  }
                } catch (manualError) {
                  addLogEntry(`Error in manual WebAssembly handling: ${manualError.message}`, 'error');
                  throw manualError;
                }
              } else {
                // If it's not a typed array error, try the normal approach
                cassette = await manager.loadCassetteFromFile(file);
              }
            }
            
            if (cassette) {
              addLogEntry(`Successfully loaded cassette: ${cassette.name}`, 'receive');
              
              // Set as active if it's the first one
              if (!activeCassetteId) {
                activeCassetteId = cassette.id;
              }
              
              // Update the UI with the loaded cassette
              updateCassetteList();
            } else {
              addLogEntry(`Cassette loaded but returned no data.`, 'error');
            }
          } catch (error) {
            addLogEntry(`Error processing cassette: ${error.message}`, 'error');
            console.error('Error details:', error);
          }
        };
        
        fileReader.onerror = (event) => {
          addLogEntry(`Error reading file: ${event.target.error}`, 'error');
        };
        
        // Start reading the file as an ArrayBuffer
        fileReader.readAsArrayBuffer(file);
      } catch (error) {
        addLogEntry(`Error loading cassette: ${error.message}`, 'error');
        console.error('Error details:', error);
      }
    }
    
    // Helper function to find exports with similar names
    function findExport(exports, possibleNames) {
      // First try exact matches
      for (const name of possibleNames) {
        if (exports[name]) {
          return exports[name];
        }
      }
      
      // Then try partial matches
      for (const name of possibleNames) {
        for (const exportName in exports) {
          if (exportName.includes(name)) {
            return exports[exportName];
          }
        }
      }
      
      // Finally, look for similar function patterns
      for (const exportName in exports) {
        if (typeof exports[exportName] === 'function') {
          // For common function patterns in WebAssembly modules
          if (exportName.endsWith('_req') || exportName.endsWith('_request') || 
              exportName.includes('_req_') || exportName.includes('_request_')) {
            return exports[exportName];
          }
        }
      }
      
      return null;
    }
    
    // Function to update the list of loaded cassettes in the UI
    function updateCassetteList() {
      const cassetteList = document.getElementById('cassette-list');
      const cassettes = manager.getCassettes();
      
      if (cassettes.length === 0) {
        cassetteList.innerHTML = `
          <div class="empty-state">
            <p>No cassettes loaded yet</p>
          </div>
        `;
        return;
      }
      
      cassetteList.innerHTML = '';
      
      // Create a tabbed interface for the cassettes
      const tabContainer = document.createElement('div');
      tabContainer.className = 'custom-tabs';
      cassetteList.appendChild(tabContainer);
      
      // Create tab content container
      const tabContent = document.createElement('div');
      tabContent.className = 'tab-content';
      cassetteList.appendChild(tabContent);
      
      // Add tabs and content for each cassette
      cassettes.forEach((cassette, index) => {
        // Create tab
        const tab = document.createElement('div');
        tab.className = `tab ${cassette.id === activeCassetteId ? 'active' : ''}`;
        tab.setAttribute('data-cassette-id', cassette.id);
        tab.innerHTML = `
          <div class="custom-tab">
            ${cassette.name}
            <button class="remove-tab" data-cassette-id="${cassette.id}">×</button>
          </div>
        `;
        tab.addEventListener('click', function() {
          // Switch to this cassette
          document.querySelectorAll('.tab-content > div').forEach(panel => {
            panel.style.display = 'none';
          });
          document.querySelectorAll('.custom-tabs .tab').forEach(t => {
            t.classList.remove('active');
          });
          
          document.getElementById(`cassette-content-${cassette.id}`).style.display = 'block';
          this.classList.add('active');
          activeCassetteId = cassette.id;
        });
        tabContainer.appendChild(tab);
        
        // Create content
        const content = document.createElement('div');
        content.id = `cassette-content-${cassette.id}`;
        content.className = 'tab-panel';
        content.style.display = cassette.id === activeCassetteId ? 'block' : 'none';
        
        // Format the metadata nicely
        let metadata = {};
        try {
          if (typeof cassette.description === 'string') {
            try {
              // Try to parse if it's a JSON string
              metadata = JSON.parse(cassette.description);
            } catch (parseError) {
              // If not valid JSON, use as plain text description
              metadata = { description: cassette.description };
            }
          } else if (cassette.description && typeof cassette.description === 'object') {
            // If it's already an object, use it directly
            metadata = cassette.description;
          } else {
            // Fallback to a default description
            metadata = { description: "No description available" };
          }
        } catch (e) {
          // Error fallback
          console.error("Error handling metadata:", e);
          metadata = { 
            description: "Metadata available but couldn't be processed",
            error: e.message
          };
        }
        
        content.innerHTML = `
          <h3>${cassette.name}</h3>
          <p class="tab-info">ID: ${cassette.id}</p>
          <div class="json-content">
            <pre>${JSON.stringify(metadata, null, 2)}</pre>
          </div>
          <div class="test-panel">
            <button class="test-cassette" data-cassette-id="${cassette.id}">Test Cassette</button>
            <div class="metrics">
              <span class="metric">Size: <span class="metric-value">${Math.round(cassette.size / 1024)} KB</span></span>
            </div>
          </div>
        `;
        tabContent.appendChild(content);
        
        // Add event listener for the test button
        content.querySelector('.test-cassette').addEventListener('click', function() {
          testCassette(cassette.id);
        });
        
        // Add event listener for the remove button
        tab.querySelector('.remove-tab').addEventListener('click', function(e) {
          e.stopPropagation();
          removeCassette(cassette.id);
        });
      });
    }
    
    // Function to send a request to the active cassette
    async function sendRequest() {
      const requestInput = document.getElementById('request-input');
      const requestStr = requestInput.value.trim();
      
      if (!requestStr) {
        addLogEntry('No request provided', 'error');
        return;
      }
      
      if (!activeCassetteId) {
        addLogEntry('No active cassette selected', 'error');
        return;
      }
      
      try {
        addLogEntry(`Sending request to cassette: ${requestStr}`, 'send');
        
        // Get the cassette to work with its methods directly
        const cassette = manager.getCassette(activeCassetteId);
        
        if (!cassette) {
          throw new Error('Could not access cassette');
        }
        
        // Get the instance and potential methods
        const instance = cassette.instance || {};
        const methods = cassette.methods || instance;
        
        let response;
        let responseDetails = {};
        
        // Try different approaches to handle the request
        try {
          // First try the standard API
          addLogEntry('Trying standard processRequest method', 'receive');
          response = manager.processRequest(activeCassetteId, requestStr);
          responseDetails.method = 'standard';
        } catch (error) {
          // If there's an error, check if it's related to typed array
          if (error.message && error.message.includes('typed array length')) {
            addLogEntry(`Handling typed array error with direct approach: ${error.message}`, 'receive');
            
            // Use direct memory handling
            try {
              response = handleRequestDirectly(cassette, requestStr);
              responseDetails.method = 'direct_memory';
            } catch (directError) {
              addLogEntry(`Direct handling failed: ${directError.message}`, 'error');
              response = JSON.stringify(["NOTICE", `Error: ${directError.message}`]);
              responseDetails.error = directError.message;
            }
          } else {
            // For other errors, try direct method invocation
            try {
              if (typeof methods.req === 'function') {
                addLogEntry('Trying direct req method call', 'receive');
                response = methods.req(requestStr);
                responseDetails.method = 'direct_method';
              } else {
                throw new Error('No req method found on cassette');
              }
            } catch (methodError) {
              addLogEntry(`Direct method call failed: ${methodError.message}`, 'error');
              response = JSON.stringify(["NOTICE", `Error: ${methodError.message}`]);
              responseDetails.error = methodError.message;
            }
          }
        }
        
        // Ensure we have a response
        if (!response) {
          addLogEntry('No response received, creating default notice', 'error');
          response = JSON.stringify(["NOTICE", "No response from cassette"]);
          responseDetails.error = 'empty_response';
        }
        
        // Log response for debugging
        addLogEntry(`Raw response: ${typeof response === 'string' ? response : JSON.stringify(response)}`, 'receive');
        addLogEntry(`Response type: ${typeof response}`, 'receive');
        if (typeof response === 'number') {
          addLogEntry(`Response is a pointer: ${response}`, 'receive');
          
          // Attempt to read the pointer directly from memory
          try {
            const memory = new Uint8Array(instance.memory.buffer);
            let responseLength = 0;
            while (memory[response + responseLength] !== 0 && responseLength < 10000) {
              responseLength++;
            }
            
            if (responseLength > 0) {
              const decoder = new TextDecoder('utf-8');
              const responseBytes = memory.slice(response, response + responseLength);
              response = decoder.decode(responseBytes);
              addLogEntry(`Successfully read response from pointer (${responseLength} bytes)`, 'receive');
            } else {
              addLogEntry('Response pointer points to empty data', 'error');
            }
          } catch (memoryError) {
            addLogEntry(`Error reading from memory: ${memoryError.message}`, 'error');
          }
        }
        
        // Make sure the response is properly formatted
        response = ensureNip01Format(response);
        
        // Display and log the response
        addLogEntry(`Processed response: ${response}`, 'receive');
        
        // Get the response container and display the response
        const responseContainer = document.getElementById('response-container');
        displayResponse(response, responseContainer);
        
        // Switch to the response tab
        document.querySelectorAll('.tab').forEach(t => {
          t.classList.remove('active');
        });
        document.querySelectorAll('.tab-panel').forEach(panel => {
          panel.classList.remove('active');
        });
        
        document.querySelector('.tab[data-tab="response"]').classList.add('active');
        document.getElementById('response-panel').classList.add('active');
      } catch (error) {
        addLogEntry(`Error sending request: ${error.message}`, 'error');
        console.error('Error details:', error);
      }
    }
    
    // Helper function to display the response
    function displayResponse(responseStr, container) {
      try {
        // Try to parse as JSON
        let responseData;
        try {
          // Try to parse as JSON
          responseData = JSON.parse(responseStr);
          
          // Determine the type of NIP-01 response for proper rendering
          if (Array.isArray(responseData) && responseData.length >= 2) {
            const messageType = responseData[0];
            
            // Format based on message type
            switch (messageType) {
              case 'EVENT':
                // For EVENT messages, format as a structured event
                container.innerHTML = `
                  <div class="response-card">
                    <h3>Response (NIP-01 EVENT)</h3>
                    <div class="json-content">
                      <pre>${JSON.stringify(responseData, null, 2)}</pre>
                    </div>
                  </div>
                `;
                break;
                
              case 'NOTICE':
                // For NOTICE messages, make the text more prominent
                container.innerHTML = `
                  <div class="response-card">
                    <h3>Response (NIP-01 NOTICE)</h3>
                    <div class="json-content">
                      <p style="font-weight: bold; color: #f44336;">${responseData[1]}</p>
                      <pre>${JSON.stringify(responseData, null, 2)}</pre>
                    </div>
                  </div>
                `;
                break;
                
              case 'EOSE':
                // For End of Stored Events messages
                container.innerHTML = `
                  <div class="response-card">
                    <h3>Response (NIP-01 EOSE)</h3>
                    <div class="json-content">
                      <p>End of Stored Events for subscription: ${responseData[1]}</p>
                      <pre>${JSON.stringify(responseData, null, 2)}</pre>
                    </div>
                  </div>
                `;
                break;
                
              case 'OK':
                // For OK messages
                container.innerHTML = `
                  <div class="response-card">
                    <h3>Response (NIP-01 OK)</h3>
                    <div class="json-content">
                      <p>Event ${responseData[1]} accepted: ${responseData[2]}</p>
                      <pre>${JSON.stringify(responseData, null, 2)}</pre>
                    </div>
                  </div>
                `;
                break;
                
              default:
                // For other types of array responses
                container.innerHTML = `
                  <div class="response-card">
                    <h3>Response (Array)</h3>
                    <div class="json-content">
                      <pre>${JSON.stringify(responseData, null, 2)}</pre>
                    </div>
                  </div>
                `;
            }
          } else {
            // For non-standard format, just display as JSON
            container.innerHTML = `
              <div class="response-card">
                <h3>Response (Non-standard format)</h3>
                <div class="json-content">
                  <pre>${JSON.stringify(responseData, null, 2)}</pre>
                </div>
              </div>
            `;
          }
        } catch (jsonError) {
          // Not valid JSON, display as raw text
          container.innerHTML = `
            <div class="response-card">
              <h3>Response (Raw)</h3>
              <div class="json-content">
                <pre>${responseStr}</pre>
              </div>
            </div>
          `;
        }
      } catch (error) {
        container.innerHTML = `
          <div class="response-card">
            <h3>Error Displaying Response</h3>
            <div class="json-content" style="color: #f44336;">
              <p>${error.message}</p>
            </div>
          </div>
        `;
      }
    }
    
    // Helper function to ensure response is in proper NIP-01 format
    function ensureNip01Format(response) {
      // If response is undefined or null, return a standard notice
      if (!response) {
        return JSON.stringify(["NOTICE", "No response received"]);
      }
      
      let parsed;
      
      // If response isn't a string, try to stringify it
      if (typeof response !== 'string') {
        try {
          response = JSON.stringify(response);
        } catch (e) {
          return JSON.stringify(["NOTICE", `Could not stringify response: ${e.message}`]);
        }
      }
      
      // Try to parse the response
      try {
        parsed = JSON.parse(response);
      } catch (e) {
        // If not valid JSON, wrap in a NOTICE
        return JSON.stringify(["NOTICE", response]);
      }
      
      // If it's already an array that looks like a NIP-01 response, return it as-is
      if (Array.isArray(parsed) && parsed.length >= 2 && 
          (parsed[0] === "EVENT" || parsed[0] === "NOTICE" || 
           parsed[0] === "EOSE" || parsed[0] === "OK")) {
        return response;
      }
      
      // If it has a notice field that is an array (common format issue), extract just the notice
      if (parsed && typeof parsed === 'object' && parsed.notice && Array.isArray(parsed.notice)) {
        return JSON.stringify(parsed.notice);
      }
      
      // If it has a message field with an array that looks like a NIP-01 array
      if (parsed && typeof parsed === 'object' && parsed.message && Array.isArray(parsed.message) &&
          parsed.message.length >= 2 && 
          (parsed.message[0] === "EVENT" || parsed.message[0] === "NOTICE" || 
           parsed.message[0] === "EOSE" || parsed.message[0] === "OK")) {
        return JSON.stringify(parsed.message);
      }
      
      // For any other type of response, wrap it in a NOTICE
      return JSON.stringify(["NOTICE", JSON.stringify(parsed)]);
    }
    
    // Direct memory handling for the request
    function handleRequestDirectly(cassette, requestStr) {
      addLogEntry("Using direct memory handling approach", "receive");
      
      const instance = cassette.instance || {};
      
      // Use the WebAssembly memory directly
      if (!instance.memory || !instance.memory.buffer) {
        throw new Error('Cannot access WebAssembly memory');
      }
      
      // Check available functions
      let reqFunction = null;
      let allocFunction = null;
      let deallocFunction = null;
      
      // Find the req function
      for (const name in instance) {
        if (name === 'req' || name.includes('_req') || name.includes('request')) {
          reqFunction = instance[name];
        } else if (name === 'allocString' || name.includes('alloc') || name.includes('malloc')) {
          allocFunction = instance[name];
        } else if (name === 'deallocString' || name.includes('dealloc') || name.includes('free')) {
          deallocFunction = instance[name];
        }
      }
      
      // Also check the methods object
      const methods = cassette.methods || {};
      if (!reqFunction && methods.req) {
        reqFunction = methods.req;
      }
      
      if (!reqFunction) {
        throw new Error('No request function found in WebAssembly module');
      }
      
      // Log what functions we found
      addLogEntry(`Found req function: ${reqFunction !== null}`, "receive");
      addLogEntry(`Found alloc function: ${allocFunction !== null}`, "receive");
      addLogEntry(`Found dealloc function: ${deallocFunction !== null}`, "receive");
      
      // Create encoder for string handling
      const encoder = new TextEncoder();
      const decoder = new TextDecoder('utf-8');
      const bytes = encoder.encode(requestStr);
      
      addLogEntry(`Request bytes length: ${bytes.length}`, "receive");
      
      // If we have memory management functions, use them
      if (allocFunction) {
        addLogEntry(`Using WebAssembly memory management functions`, 'receive');
        
        // Allocate memory with extra padding
        const padding = 16; // Add padding to prevent typed array length errors
        const ptr = allocFunction(bytes.length + padding);
        
        // Get memory view
        const memory = new Uint8Array(instance.memory.buffer);
        
        // Write the request data
        for (let i = 0; i < bytes.length; i++) {
          memory[ptr + i] = bytes[i];
        }
        memory[ptr + bytes.length] = 0; // Null terminator
        
        // Call the request function
        const resultPtr = reqFunction(ptr, bytes.length);
        
        // Read the result string from memory
        let resultLength = 0;
        // Find the length of the string (until null terminator)
        while (memory[resultPtr + resultLength] !== 0 && resultLength < 10000) {
          resultLength++;
        }
        
        // Extract the result string
        const resultBytes = memory.slice(resultPtr, resultPtr + resultLength);
        const resultStr = decoder.decode(resultBytes);
        
        addLogEntry(`Retrieved result string (${resultLength} bytes)`, 'receive');
        
        // Free memory if possible
        if (deallocFunction) {
          deallocFunction(ptr, bytes.length);
          // Also free the result pointer if necessary
          deallocFunction(resultPtr, resultLength);
        }
        
        return resultStr;
      } else {
        // Try direct invocation with the string
        addLogEntry(`Trying direct function call with string`, 'receive');
        return reqFunction(requestStr);
      }
    }
    
    // Function to test a cassette with a basic request
    function testCassette(cassetteId) {
      try {
        const testRequest = JSON.stringify(["REQ", "test1", {"limit": 1}]);
        addLogEntry(`Testing cassette ${cassetteId} with request: ${testRequest}`, 'send');
        
        const response = manager.processRequest(cassetteId, testRequest);
        
        if (response) {
          addLogEntry(`Test response: ${response}`, 'receive');
        } else {
          addLogEntry(`No response from test`, 'error');
        }
      } catch (error) {
        addLogEntry(`Error testing cassette: ${error.message}`, 'error');
      }
    }
    
    // Function to remove a cassette
    function removeCassette(cassetteId) {
      try {
        manager.removeCassette(cassetteId);
        addLogEntry(`Removed cassette: ${cassetteId}`, 'receive');
        
        // Update UI and select a new active cassette if needed
        if (activeCassetteId === cassetteId) {
          const cassettes = manager.getCassettes();
          activeCassetteId = cassettes.length > 0 ? cassettes[0].id : null;
        }
        
        updateCassetteList();
      } catch (error) {
        addLogEntry(`Error removing cassette: ${error.message}`, 'error');
      }
    }
  </script>
</body>
</html>
